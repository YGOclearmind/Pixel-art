<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>像素艺术生成器</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            display: flex;
            gap: 20px;
        }

        .main-content {
            flex: 1;
            margin-right: 220px; /* 180px + 20px*2 */
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: min-content;
            min-width: 180px;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
            position: fixed;
            right: 20px;
            top: 20px;
            height: calc(100vh - 40px);
            overflow-y: auto;
            box-sizing: border-box;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            min-width: 150px;
        }
        
        label {
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        input, select, button {
            padding: 8px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
        }
        
        button {
            background-color: #3498db;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
            border: none;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        .color-picker {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #color {
            width: 50px;
            height: 30px;
            padding: 0;
            border: 1px solid #bdc3c7;
        }
        
        .canvas-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        #pixelCanvas {
            border: 1px solid #bdc3c7;
            background-color: white;
            box-shadow: 0 0 5px rgba(0,0,0,0.1);
        }
        
        .template-preview {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        
        .template {
            width: 50px;
            height: 50px;
            border: 2px solid transparent;
            cursor: pointer;
        }
        
        .template:hover {
            border-color: #3498db;
        }
        
        .tools {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .tool-btn {
            flex: 1;
        }
        
        .template-import {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <div class="control-group">
                <label>绘图工具</label>
                <select id="drawingTool">
                    <option value="pencil" selected>铅笔</option>
                    <option value="line">直线</option>
                    <option value="rectangle">矩形</option>
                    <option value="circle">圆形</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>调色板</label>
                <div class="palette" id="colorPalette">
                    <!-- 调色板颜色将在这里动态生成 -->
                </div>
                <button id="saveColorBtn" style="margin-top: 5px;">保存当前颜色</button>
            </div>
            
            <div class="control-group">
                <label for="gridSize">画布大小</label>
                <select id="gridSize">
                    <option value="16">16×16 (小图标)</option>
                    <option value="32" selected>32×32 (头像)</option>
                    <option value="64">64×64</option>
                    <option value="128">128×128</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="pixelSize">像素大小</label>
                <select id="pixelSize">
                    <option value="10">10px</option>
                    <option value="15" selected>15px</option>
                    <option value="20">20px</option>
                    <option value="25">25px</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>颜色</label>
                <div class="color-picker">
                    <input type="color" id="color" value="#3498db">
                    <button id="randomColor">随机</button>
                    <button id="gradientMode">渐变模式</button>
                </div>
            </div>
            
            <div class="control-group">
                <label>模板</label>
                <select id="templateSelect">
                    <option value="">选择模板...</option>
                    <option value="heart">爱心</option>
                    <option value="smile">笑脸</option>
                    <option value="tree">圣诞树</option>
                    <option value="cat">猫咪</option>
                </select>
                <div class="template-import">
                    <label for="imageUpload">或导入图片</label>
                    <input type="file" id="imageUpload" accept="image/*">
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <h1>像素艺术生成器</h1>
            
            <div class="canvas-container">
                <canvas id="pixelCanvas"></canvas>
            </div>
            
            <div class="tools">
            <button id="undoBtn" class="tool-btn" title="撤销 (Ctrl+Z)">↩️ 撤销</button>
            <button id="redoBtn" class="tool-btn" title="重做 (Ctrl+Y)">↪️ 重做</button>
            <button id="clearCanvas" class="tool-btn">清空画布</button>
            <button id="saveProject" class="tool-btn">保存项目</button>
            <button id="loadProject" class="tool-btn">加载项目</button>
            <button id="exportPNG" class="tool-btn">导出PNG</button>
        </div>
        
        <div class="template-preview" id="templatePreviews">
            <!-- 模板预览将在这里动态生成 -->
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // 获取DOM元素
            const canvas = document.getElementById('pixelCanvas');
            const ctx = canvas.getContext('2d');
            const gridSizeSelect = document.getElementById('gridSize');
            const pixelSizeSelect = document.getElementById('pixelSize');
            const colorPicker = document.getElementById('color');
            const randomColorBtn = document.getElementById('randomColor');
            const templateSelect = document.getElementById('templateSelect');
            const imageUpload = document.getElementById('imageUpload');
            const clearCanvasBtn = document.getElementById('clearCanvas');
            const exportPNGBtn = document.getElementById('exportPNG');
            const templatePreviews = document.getElementById('templatePreviews');
            
            // 初始化变量
            let gridSize = parseInt(gridSizeSelect.value);
            let pixelSize = parseInt(pixelSizeSelect.value);
            let currentColor = colorPicker.value;
            let isDrawing = false;
            let isErasing = false;
            let isGradientMode = false;
            let currentTool = 'pencil';
            let startX, startY;
            let paletteColors = JSON.parse(localStorage.getItem('paletteColors')) || [];
            
            // 撤销/重做历史记录
            const MAX_HISTORY = 50;
            let historyStack = [];
            let redoStack = [];
            
            // 预定义模板
            const templates = {
                heart: {
                    size: 16,
                    data: [
                        [0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0],
                        [0,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0],
                        [1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                        [1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                        [1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                        [0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                        [0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
                        [0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0],
                        [0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0],
                        [0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                    ],
                    color: '#ff0000'
                },
                smile: {
                    size: 16,
                    data: [
                        [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
                        [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                        [1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0],
                        [1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0],
                        [1,1,0,1,1,0,0,0,0,1,1,0,1,1,0,0],
                        [1,1,0,1,1,0,0,0,0,1,1,0,1,1,0,0],
                        [1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0],
                        [1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0],
                        [1,1,0,1,0,0,0,0,0,0,1,0,1,1,0,0],
                        [1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0],
                        [0,1,1,0,0,0,1,1,0,0,0,1,1,0,0,0],
                        [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0]
                    ],
                    color: '#ffff00'
                },
                tree: {
                    size: 16,
                    data: [
                        [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0],
                        [0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0],
                        [0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0],
                        [0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0],
                        [0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0],
                        [0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
                        [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0]
                    ],
                    color: '#00aa00'
                },
                cat: {
                    size: 16,
                    data: [
                        [0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0],
                        [0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],
                        [0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
                        [0,1,1,1,0,0,1,1,1,1,0,0,1,1,1,0],
                        [0,1,1,1,0,0,1,1,1,1,0,0,1,1,1,0],
                        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                        [1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,1],
                        [1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1],
                        [0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0]
                    ],
                    color: '#ffa500'
                }
            };
            
            // 初始化画布
            function initCanvas() {
                gridSize = parseInt(gridSizeSelect.value);
                pixelSize = parseInt(pixelSizeSelect.value);
                
                canvas.width = gridSize * pixelSize;
                canvas.height = gridSize * pixelSize;
                
                // 绘制网格
                drawGrid();
                
                // 生成模板预览
                generateTemplatePreviews();
            }
            
            // 绘制网格
            function drawGrid() {
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 0.5;
                
                for (let x = 0; x <= gridSize; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x * pixelSize, 0);
                    ctx.lineTo(x * pixelSize, gridSize * pixelSize);
                    ctx.stroke();
                }
                
                for (let y = 0; y <= gridSize; y++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y * pixelSize);
                    ctx.lineTo(gridSize * pixelSize, y * pixelSize);
                    ctx.stroke();
                }
            }
            
            // 生成模板预览
            function generateTemplatePreviews() {
                templatePreviews.innerHTML = '';
                
                for (const [name, template] of Object.entries(templates)) {
                    const previewCanvas = document.createElement('canvas');
                    previewCanvas.width = template.size;
                    previewCanvas.height = template.size;
                    previewCanvas.className = 'template';
                    previewCanvas.dataset.template = name;
                    
                    const previewCtx = previewCanvas.getContext('2d');
                    
                    // 绘制模板预览
                    for (let y = 0; y < template.data.length; y++) {
                        for (let x = 0; x < template.data[y].length; x++) {
                            if (template.data[y][x]) {
                                previewCtx.fillStyle = template.color;
                                previewCtx.fillRect(x, y, 1, 1);
                            }
                        }
                    }
                    
                    previewCanvas.addEventListener('click', function() {
                        applyTemplate(name);
                    });
                    
                    templatePreviews.appendChild(previewCanvas);
                }
            }
            
            // 应用模板
            function applyTemplate(templateName) {
                const template = templates[templateName];
                currentColor = template.color;
                colorPicker.value = currentColor;
                
                // 计算缩放比例
                const scale = gridSize / template.size;
                
                // 清空画布
                drawGrid();
                
            // 保存状态
            saveState();
            updateUndoRedoButtons();
                
                // 绘制模板
                for (let y = 0; y < template.data.length; y++) {
                    for (let x = 0; x < template.data[y].length; x++) {
                        if (template.data[y][x]) {
                            const scaledX = Math.floor(x * scale);
                            const scaledY = Math.floor(y * scale);
                            const scaledSize = Math.max(1, Math.floor(scale));
                            
                            ctx.fillStyle = currentColor;
                            ctx.fillRect(
                                scaledX * pixelSize, 
                                scaledY * pixelSize, 
                                scaledSize * pixelSize, 
                                scaledSize * pixelSize
                            );
                        }
                    }
                }
            }
            
            // 从图片导入
            function importImage(file) {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        // 清空画布
                        drawGrid();
                        
                        // 计算缩放比例
                        const scale = Math.min(
                            canvas.width / img.width,
                            canvas.height / img.height
                        );
                        
                        // 绘制图像
                        ctx.drawImage(
                            img, 
                            0, 0, img.width, img.height,
                            0, 0, img.width * scale, img.height * scale
                        );
                        
                        // 像素化处理
                        pixelateImage();
                    };
                    img.src = e.target.result;
                };
                
                reader.readAsDataURL(file);
            }
            
            // 像素化图像
            function pixelateImage() {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        const pixelX = x * pixelSize;
                        const pixelY = y * pixelSize;
                        
                        // 获取中心点颜色
                        const centerX = pixelX + Math.floor(pixelSize / 2);
                        const centerY = pixelY + Math.floor(pixelSize / 2);
                        
                        const index = (centerY * canvas.width + centerX) * 4;
                        const r = data[index];
                        const g = data[index + 1];
                        const b = data[index + 2];
                        const a = data[index + 3];
                        
                        // 填充整个像素块
                        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a / 255})`;
                        ctx.fillRect(pixelX, pixelY, pixelSize, pixelSize);
                    }
                }
            }
            
            // 获取鼠标位置对应的网格坐标
            function getGridPosition(event) {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((event.clientX - rect.left) / pixelSize);
                const y = Math.floor((event.clientY - rect.top) / pixelSize);
                
                return { 
                    x: Math.max(0, Math.min(x, gridSize - 1)),
                    y: Math.max(0, Math.min(y, gridSize - 1))
                };
            }
            
            // 保存当前画布状态
            function saveState() {
                // 保存当前状态到历史记录
                const state = canvas.toDataURL('image/png');
                historyStack.push(state);
                
                // 限制历史记录数量
                if (historyStack.length > MAX_HISTORY) {
                    historyStack.shift();
                }
                
                // 清空重做栈
                redoStack = [];
            }
            
            // 恢复画布状态
            function restoreState(state) {
                const img = new Image();
                img.onload = function() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = state;
            }
            
            // 撤销操作
            function undo() {
                if (historyStack.length > 0) {
                    const state = historyStack.pop();
                    redoStack.push(canvas.toDataURL('image/png'));
                    restoreState(state);
                    updateUndoRedoButtons();
                }
            }
            
            // 重做操作
            function redo() {
                if (redoStack.length > 0) {
                    const state = redoStack.pop();
                    historyStack.push(canvas.toDataURL('image/png'));
                    restoreState(state);
                    updateUndoRedoButtons();
                }
            }
            
            // 绘制直线
            function drawLine(x1, y1, x2, y2) {
                const dx = Math.abs(x2 - x1);
                const dy = Math.abs(y2 - y1);
                const sx = (x1 < x2) ? 1 : -1;
                const sy = (y1 < y2) ? 1 : -1;
                let err = dx - dy;
                
                while(true) {
                    drawPixel(x1, y1);
                    
                    if (x1 === x2 && y1 === y2) break;
                    const e2 = 2 * err;
                    if (e2 > -dy) { err -= dy; x1 += sx; }
                    if (e2 < dx) { err += dx; y1 += sy; }
                }
            }
            
            // 绘制矩形
            function drawRectangle(x1, y1, x2, y2, filled = true) {
                const minX = Math.min(x1, x2);
                const maxX = Math.max(x1, x2);
                const minY = Math.min(y1, y2);
                const maxY = Math.max(y1, y2);
                
                if (filled) {
                    for (let y = minY; y <= maxY; y++) {
                        for (let x = minX; x <= maxX; x++) {
                            drawPixel(x, y);
                        }
                    }
                } else {
                    // 绘制边框
                    for (let x = minX; x <= maxX; x++) {
                        drawPixel(x, minY);
                        drawPixel(x, maxY);
                    }
                    for (let y = minY + 1; y < maxY; y++) {
                        drawPixel(minX, y);
                        drawPixel(maxX, y);
                    }
                }
            }
            
            // 绘制圆形
            function drawCircle(x1, y1, x2, y2, filled = true) {
                const radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const centerX = x1;
                const centerY = y1;
                
                for (let y = -radius; y <= radius; y++) {
                    for (let x = -radius; x <= radius; x++) {
                        if (x*x + y*y <= radius*radius + radius*0.8) { // 添加0.8因子使圆形更平滑
                            if (filled || Math.abs(x*x + y*y - radius*radius) <= radius) {
                                const px = Math.round(centerX + x);
                                const py = Math.round(centerY + y);
                                if (px >= 0 && px < gridSize && py >= 0 && py < gridSize) {
                                    drawPixel(px, py);
                                }
                            }
                        }
                    }
                }
            }
            
            // 绘制像素
            function drawPixel(x, y) {
                ctx.fillStyle = isErasing ? '#ffffff' : currentColor;
                ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                
                // 重新绘制网格线
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 0.5;
                ctx.strokeRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
            }
            
            // 填充算法 (类似油漆桶工具)
            function floodFill(startX, startY, targetColor, replacementColor) {
                // 将颜色转换为字符串比较
                targetColor = colorToRGBA(targetColor);
                replacementColor = colorToRGBA(replacementColor);
                
                // 如果目标颜色和替换颜色相同，不做任何操作
                if (targetColor === replacementColor) return;
                
                // 获取初始像素颜色
                const initialPixel = ctx.getImageData(startX * pixelSize, startY * pixelSize, 1, 1).data;
                const initialColor = `rgba(${initialPixel[0]}, ${initialPixel[1]}, ${initialPixel[2]}, ${initialPixel[3] / 255})`;
                
                // 如果初始颜色不是目标颜色，不做任何操作
                if (initialColor !== targetColor) return;
                
                // 使用队列实现泛洪填充
                const queue = [{x: startX, y: startY}];
                const width = gridSize;
                const height = gridSize;
                
                // 记录已访问的像素
                const visited = new Array(width * height).fill(false);
                
                while (queue.length > 0) {
                    const {x, y} = queue.shift();
                    const index = y * width + x;
                    
                    // 检查边界和是否已访问
                    if (x < 0 || x >= width || y < 0 || y >= height || visited[index]) {
                        continue;
                    }
                    
                    // 获取当前像素颜色
                    const pixel = ctx.getImageData(x * pixelSize, y * pixelSize, 1, 1).data;
                    const currentColor = `rgba(${pixel[0]}, ${pixel[1]}, ${pixel[2]}, ${pixel[3] / 255})`;
                    
                    // 如果颜色匹配，则填充并检查相邻像素
                    if (currentColor === targetColor) {
                        ctx.fillStyle = replacementColor;
                        ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                        
                        // 重新绘制网格线
                        ctx.strokeStyle = '#e0e0e0';
                        ctx.lineWidth = 0.5;
                        ctx.strokeRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                        
                        visited[index] = true;
                        
                        // 添加相邻像素到队列
                        queue.push({x: x + 1, y});
                        queue.push({x: x - 1, y});
                        queue.push({x, y: y + 1});
                        queue.push({x, y: y - 1});
                    }
                }
            }
            
            // 将颜色转换为RGBA字符串
            function colorToRGBA(color) {
                // 如果是十六进制颜色
                if (color.startsWith('#')) {
                    const r = parseInt(color.substr(1, 2), 16);
                    const g = parseInt(color.substr(3, 2), 16);
                    const b = parseInt(color.substr(5, 2), 16);
                    return `rgba(${r}, ${g}, ${b}, 1)`;
                }
                
                // 如果是rgb或rgba颜色
                return color;
            }
            
            // 生成随机相近颜色（基于当前颜色）
            function getRandomColor(baseColor = currentColor) {
                // 将十六进制颜色转换为HSL
                const hexToHsl = hex => {
                    let r = parseInt(hex.slice(1, 3), 16) / 255;
                    let g = parseInt(hex.slice(3, 5), 16) / 255;
                    let b = parseInt(hex.slice(5, 7), 16) / 255;
                    
                    let max = Math.max(r, g, b), min = Math.min(r, g, b);
                    let h, s, l = (max + min) / 2;
                    
                    if (max === min) {
                        h = s = 0; // achromatic
                    } else {
                        let d = max - min;
                        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                        
                        switch(max) {
                            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                            case g: h = (b - r) / d + 2; break;
                            case b: h = (r - g) / d + 4; break;
                        }
                        h /= 6;
                    }
                    
                    return { h: h * 360, s: s * 100, l: l * 100 };
                };
                
                // 将HSL转换为十六进制
                const hslToHex = (h, s, l) => {
                    h /= 360;
                    s /= 100;
                    l /= 100;
                    
                    let r, g, b;
                    
                    if (s === 0) {
                        r = g = b = l; // achromatic
                    } else {
                        const hue2rgb = (p, q, t) => {
                            if (t < 0) t += 1;
                            if (t > 1) t -= 1;
                            if (t < 1/6) return p + (q - p) * 6 * t;
                            if (t < 1/2) return q;
                            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                            return p;
                        };
                        
                        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                        const p = 2 * l - q;
                        
                        r = hue2rgb(p, q, h + 1/3);
                        g = hue2rgb(p, q, h);
                        b = hue2rgb(p, q, h - 1/3);
                    }
                    
                    const toHex = x => {
                        const hex = Math.round(x * 255).toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    };
                    
                    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
                };
                
                // 获取基础颜色的HSL值
                let {h, s, l} = hexToHsl(baseColor);
                
                // 限制饱和度和亮度在美观范围内
                s = Math.max(60, Math.min(90, s));
                l = Math.max(40, Math.min(80, l));
                
                // 在HSL空间中进行更平滑的调整
                // 色相变化±10度，保持变化方向一致（顺时针）
                const newH = (h + Math.random() * 10 + 360) % 360;
                // 饱和度轻微变化±5%
                const newS = Math.max(60, Math.min(90, s + Math.random() * 10 - 5));
                // 亮度轻微变化±5% 
                const newL = Math.max(40, Math.min(80, l + Math.random() * 10 - 5));
                
                return hslToHex(newH, newS, newL);
            }
            
            // 导出为PNG
            function exportToPNG() {
                const link = document.createElement('a');
                link.download = 'pixel-art.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            }
            
            // 保存项目
            function saveProject() {
                const project = {
                    gridSize: gridSize,
                    pixelSize: pixelSize,
                    currentColor: currentColor,
                    canvasData: canvas.toDataURL('image/png'),
                    paletteColors: paletteColors,
                    version: 1
                };
                
                const data = JSON.stringify(project);
                const blob = new Blob([data], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.download = 'pixel-art-project.json';
                link.href = url;
                link.click();
                
                URL.revokeObjectURL(url);
            }
            
            // 加载项目
            function loadProject() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                
                input.onchange = e => {
                    const file = e.target.files[0];
                    const reader = new FileReader();
                    
                    reader.onload = function(e) {
                        try {
                            const project = JSON.parse(e.target.result);
                            
                            // 验证项目文件
                            if (!project.version || project.version !== 1) {
                                throw new Error('不兼容的项目文件版本');
                            }
                            
                            // 恢复项目状态
                            gridSize = project.gridSize;
                            pixelSize = project.pixelSize;
                            currentColor = project.currentColor;
                            paletteColors = project.paletteColors || [];
                            
                            // 更新UI
                            gridSizeSelect.value = gridSize;
                            pixelSizeSelect.value = pixelSize;
                            colorPicker.value = currentColor;
                            
                            // 恢复画布
                            const img = new Image();
                            img.onload = function() {
                                initCanvas();
                                ctx.drawImage(img, 0, 0);
                                generatePalette();
                                saveState();
                                updateUndoRedoButtons();
                            };
                            img.src = project.canvasData;
                            
                        } catch (error) {
                            alert('加载项目失败: ' + error.message);
                        }
                    };
                    
                    reader.readAsText(file);
                };
                
                input.click();
            }
            
            // 事件监听器
            canvas.addEventListener('mousedown', function(e) {
                if (e.button !== 0) return; // 只响应左键
                isDrawing = true;
                const { x, y } = getGridPosition(e);
                startX = x;
                startY = y;
                
                if (e.ctrlKey || e.metaKey) {
                    // 按住Ctrl键(Mac上是Command键)进行填充
                    floodFill(x, y, '#ffffff', currentColor);
                    saveState();
                    isDrawing = false;
                    return;
                }
                
                // 设置绘制状态
                isErasing = e.shiftKey;
                
                // 如果是渐变模式，初始化随机颜色
                if (isGradientMode && !isErasing) {
                    currentColor = getRandomColor();
                    colorPicker.value = currentColor;
                }
                
                // 绘制起始点
                if (currentTool === 'pencil') {
                    drawPixel(x, y);
                }
            });
            
            canvas.addEventListener('mousemove', function(e) {
                if (!isDrawing) return;
                const { x, y } = getGridPosition(e);
                
                // 临时画布用于预览
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(canvas, 0, 0);
                
                switch(currentTool) {
                    case 'pencil':
                        if (isGradientMode && !isErasing) {
                            // 在渐变模式下，每次移动时轻微改变颜色
                            currentColor = getRandomColor(currentColor);
                            colorPicker.value = currentColor;
                        }
                        drawPixel(x, y);
                        break;
                    case 'line':
                        drawLine(startX, startY, x, y);
                        break;
                    case 'rectangle':
                        if (e.shiftKey) {
                            // 按住Shift键绘制正方形
                            const size = Math.max(Math.abs(x - startX), Math.abs(y - startY));
                            const endX = startX + (x > startX ? size : -size);
                            const endY = startY + (y > startY ? size : -size);
                            drawRectangle(startX, startY, endX, endY, !e.altKey);
                        } else {
                            drawRectangle(startX, startY, x, y, !e.altKey);
                        }
                        break;
                    case 'circle':
                        if (e.shiftKey) {
                            // 按住Shift键绘制正圆
                            const radius = Math.max(Math.abs(x - startX), Math.abs(y - startY));
                            const endX = startX + (x > startX ? radius : -radius);
                            const endY = startY + (y > startY ? radius : -radius);
                            drawCircle(startX, startY, endX, endY, !e.altKey);
                        } else {
                            drawCircle(startX, startY, x, y, !e.altKey);
                        }
                        break;
                }
            });
            
            canvas.addEventListener('mouseup', function() {
                if (isDrawing) {
                    saveState();
                    updateUndoRedoButtons();
                }
                isDrawing = false;
            });
            
            // 工具选择变化
            document.getElementById('drawingTool').addEventListener('change', function() {
                currentTool = this.value;
            });
            
            canvas.addEventListener('mouseleave', function() {
                isDrawing = false;
            });
            
            gridSizeSelect.addEventListener('change', initCanvas);
            pixelSizeSelect.addEventListener('change', initCanvas);
            colorPicker.addEventListener('input', function() {
                currentColor = this.value;
            });
            
            randomColorBtn.addEventListener('click', function() {
                currentColor = getRandomColor();
                colorPicker.value = currentColor;
            });

            // 渐变模式按钮
            const gradientModeBtn = document.getElementById('gradientMode');
            gradientModeBtn.addEventListener('click', function() {
                isGradientMode = !isGradientMode;
                this.style.backgroundColor = isGradientMode ? '#2980b9' : '#3498db';
            });
            
            templateSelect.addEventListener('change', function() {
                if (this.value) {
                    applyTemplate(this.value);
                    this.value = '';
                }
            });
            
            imageUpload.addEventListener('change', function() {
                if (this.files && this.files[0]) {
                    importImage(this.files[0]);
                    this.value = ''; // 清除选择，以便可以重复选择同一文件
                }
            });
            
            clearCanvasBtn.addEventListener('click', drawGrid);
            exportPNGBtn.addEventListener('click', exportToPNG);
            
            // 项目保存/加载
            const saveProjectBtn = document.getElementById('saveProject');
            const loadProjectBtn = document.getElementById('loadProject');
            
            saveProjectBtn.addEventListener('click', saveProject);
            loadProjectBtn.addEventListener('click', loadProject);
            
            // 撤销/重做按钮
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            
            // 更新按钮状态
            function updateUndoRedoButtons() {
                undoBtn.disabled = historyStack.length === 0;
                redoBtn.disabled = redoStack.length === 0;
            }
            
            // 键盘事件监听
            document.addEventListener('keydown', function(e) {
                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 'z') {
                        undo();
                        e.preventDefault();
                    } else if (e.key === 'y') {
                        redo();
                        e.preventDefault();
                    }
                }
            });
            
            // 生成调色板
            function generatePalette() {
                const palette = document.getElementById('colorPalette');
                palette.innerHTML = '';
                
                paletteColors.forEach((color, index) => {
                    const colorDiv = document.createElement('div');
                    colorDiv.className = 'palette-color';
                    colorDiv.style.backgroundColor = color;
                    colorDiv.title = color;
                    colorDiv.style.width = '20px';
                    colorDiv.style.height = '20px';
                    colorDiv.style.display = 'inline-block';
                    colorDiv.style.margin = '2px';
                    colorDiv.style.cursor = 'pointer';
                    colorDiv.style.border = '1px solid #ddd';
                    
                    colorDiv.addEventListener('click', function() {
                        currentColor = color;
                        colorPicker.value = color;
                    });
                    
                    // 右键删除颜色
                    colorDiv.addEventListener('contextmenu', function(e) {
                        e.preventDefault();
                        paletteColors.splice(index, 1);
                        localStorage.setItem('paletteColors', JSON.stringify(paletteColors));
                        generatePalette();
                    });
                    
                    palette.appendChild(colorDiv);
                });
            }
            
            // 保存当前颜色到调色板
            document.getElementById('saveColorBtn').addEventListener('click', function() {
                const color = colorPicker.value;
                if (!paletteColors.includes(color)) {
                    paletteColors.push(color);
                    localStorage.setItem('paletteColors', JSON.stringify(paletteColors));
                    generatePalette();
                }
            });
            
            // 初始化
            initCanvas();
            generatePalette();
            updateUndoRedoButtons();
            saveState(); // 保存初始状态
        });
    </script>
</body>
</html>